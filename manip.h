#ifdef _MSC_VER
#pragma once
#endif	// _MSC_VER

//---------------------------------------------------------------------------

#ifndef ManipH
#define ManipH
//---------------------------------------------------------------------------


#include <array>
#include <string>
#include <algorithm>

////////////////////////////////////////////////////////////////////////////////
// Manipulator bitfield_mask_t could be used with custom enums,
// generated by PP_ADAPT_COMPLEX_ENUM_<opt. _CLASS> macros
// http://stackoverflow.com/questions/6478745/custom-stream-manipulator-for-streaming-integers-in-any-base
//  was used for inspiration.
////////////////////////////////////////////////////////////////////////////////
template <typename TEnum>
class bitfield_mask_t
{
private:
    using itself = bitfield_mask_t<TEnum>;

    std::uint32_t m_mask;

    static int get_idx()
    {
        // call xalloc once to get an index at which we can store data for this
        // manipulator.
        static int const idx = std::ios_base::xalloc();
        return idx;
    }

    template <typename TChar, typename TCharTraits>
    void apply(std::basic_ostream<TChar, TCharTraits> &ostr) const
    {
        // set mask
        ostr.iword(get_idx()) = m_mask + 1;
    }
public:
    bitfield_mask_t(TEnum mask) : m_mask { static_cast<std::uint32_t>(mask) } {}

    template <typename TChar, typename TCharTraits>
    static auto get_mask(std::basic_ostream<TChar, TCharTraits> &ostr)
    {
        using und_type = typename std::underlying_type<TEnum>::type;

        // default value will be 0xFFFFFFFF
        return static_cast<und_type>(ostr.iword(get_idx()) - 1);
    }

    template <typename TChar, typename TCharTraits>
    friend auto &operator << (std::basic_ostream<TChar, TCharTraits> &ostr, itself const &em)
    {
        em.apply(ostr);
        return ostr;
    }
};

template <typename TEnum> auto bitfield_mask(TEnum en) { return bitfield_mask_t<TEnum>{ en }; }

////////////////////////////////////////////////////////////////////////////////
// Manipulator basic_bitfield_delim_t for customizing delimiter between
// bitfield elements during output.
// Default value is " "
////////////////////////////////////////////////////////////////////////////////
template <typename TChar, typename TCharTraits>
class basic_bitfield_delim_t
{
public:
    static_assert(sizeof(long) >= sizeof(TChar), "Char is too big");

    static auto constexpr arr_count = sizeof(long) / sizeof(TChar);
    using delim_type = std::basic_string<TChar, TCharTraits>;
private:
    using delim_storage_type = std::array<TChar, arr_count>;
    using delim_idx_storage_type = TChar const (&)[arr_count];
    using itself = basic_bitfield_delim_t<TChar, TCharTraits>;

    delim_storage_type  m_delim;
    std::size_t const   m_delim_length;
        // this value is set by default
    static const long space_val = 0L;
    static const long empty_val = -1L;

    static auto constexpr space_impl(char) { return " "; }
    static auto constexpr space_impl(wchar_t) { return L" "; }
    static auto constexpr space() { return space_impl(TChar {}); }

    static auto constexpr empty_impl(char) { return ""; }
    static auto constexpr empty_impl(wchar_t) { return L""; }
    static auto constexpr empty() { return empty_impl(TChar {}); }

    static int get_idx()
    {
        // call xalloc once to get an index at which we can store data for this
        // manipulator.
        static int const idx = std::ios_base::xalloc();
        return idx;
    }

    void apply(std::basic_ostream<TChar, TCharTraits> &ostr) const
    {
        // not marked as constexpr
        static auto const empty_length = TCharTraits::length(empty());
        assert(0 == empty_length);

        static auto const space_length = TCharTraits::length(space());

        // set delimiter
        static auto const idx = get_idx();
        if (empty_length == m_delim_length)
        {
            ostr.iword(idx) = empty_val;
        }
        else if
        (
            space_length == m_delim_length &&
            0 == TCharTraits::compare(space(), m_delim.data(), m_delim_length)
        )
        {
            ostr.iword(idx) = space_val;
        }
        else
        {
            ostr.iword(idx) = *reinterpret_cast<long const *>(m_delim.data());
        }
    }
public:
    itself(): m_delim_length{ 0 } {}

    template <std::size_t N_>
    itself(TChar const (&delim)[N_]) : m_delim_length { 0 }
    {
        // VS 2015: not constexpr yet
        static_assert(N_ <= arr_count, "String is too big.");

        // VS 2015 problem with aggregate initialization
        std::copy(&delim[0], &delim[N_], m_delim.begin());
        const_cast<std::size_t &>(m_delim_length) = TCharTraits::length(m_delim.data());
    }

    static delim_type get_delim(std::basic_ostream<TChar, TCharTraits> &ostr)
    {
        auto const val = ostr.iword(get_idx());
        switch (val)
        {
        case empty_val:
            return empty();

        case space_val:
            return space();

        default:
            return reinterpret_cast<delim_idx_storage_type>(val);
        }
    }

    friend decltype(auto) operator << (std::basic_ostream<TChar, TCharTraits> &ostr, itself const &bfd)
    {
        bfd.apply(ostr);
        return ostr;
    }
};

template <
    typename TChar,
    std::size_t N_,
    typename TCharTraits = std::char_traits<TChar> >
auto bitfield_delim(TChar const (&delim)[N_])
{ return basic_bitfield_delim_t<TChar, TCharTraits>{ delim }; }

template <typename TChar, typename TCharTraits = std::char_traits<TChar> >
auto bitfield_delim() { return basic_bitfield_delim_t<TChar, TCharTraits>{}; }

struct blank
{
    template <typename TCharTraits>
    friend auto &operator << (std::basic_ostream<char, TCharTraits> &ostr, blank) { return (ostr << " "); }

    template <typename TCharTraits>
    friend auto &operator << (std::basic_ostream<wchar_t, TCharTraits> &ostr, blank) { return (ostr << L" "); }
};

#endif   // ManipH